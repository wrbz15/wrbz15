---
title: 重构的原则
date: 2022-08-27T19:17:58+08:00
lastmod: 2022-08-27T19:17:58+08:00
author: ["wrbz15"]
categories: 
- 敏捷开发
tags: 
- 敏捷开发
- 重构
description: ""
weight: # 输入1可以顶置文章，用来给文章展示排序，不填就默认按时间排序
slug: ""
draft: false # 是否为草稿
comments: true
showToc: true # 显示目录
TocOpen: true # 自动展开目录
hidemeta: false # 是否隐藏文章的元信息，如发布日期、作者等
disableShare: true # 底部不显示分享栏
showbreadcrumbs: true #顶部显示当前路径
Date: 
cover:
    image: ""
    caption: ""
    alt: ""
    relative: false
---
## 重构的定义
* 重构（名词）：对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。
* 重构（动词）：使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构。
## 重构与性能优化对比
相同点：
* 需要修改代码
* 不会改变程序的整体功能
  
不同点：
* 重构是为了让代码“更容易理解，更易于修改”
* 在性能优化时，我只关心让程序运行得更快，最终得到的代码有可能更难理解和维护

## 重构的目的
> 良好的设计必须在开始编程之前完成，因为一旦开始编写代码，设计就只会逐渐腐败。重构改变了这个图景。现在我们可以改善已有代码的设计，因此我们可以先做一个设计，然后不断改善它，哪怕程序本身的功能也在不断发生着变化。由于预先做出良好的设计非常困难，想要既体面又快速地开发功能，重构必不可少。
* 重构改进软件的设计
* 重构使软件更容易理解
* 重构帮助找到 bug
* 重构帮助找到 bug

## 重构的时机
> 三次法则  
> 第一次做某件事时只管去做；第二次做类似的事会产生反感，但无论如何还是可以去做；第三次再做类似的事，你就应该重构。  
> 正如老话说的：事不过三，三则重构。  

应该做重构的时机：
* 预备性重构：让添加新功能更容易 
* 帮助理解的重构：使代码更易懂
* 捡垃圾式重构
* 有计划的重构和见机行事的重构
* 长期重构
* 复审代码时重构

不应该重构的时机：
* 不需要修改它，那么就不需要重构它
* 如果重写比重构还容易，就别重构了

## 重构的挑战
### 延缓新功能开发：
-- 尽管重构的目的是加快开发速度，但是，仍旧很多人认为，花在重构的时间是在拖慢新功能的开发进度
* 预备性重构常会使修改更容易，所以如果做一点儿重构能让新功能实现更容易，我一定会做
* 如果一块代码我很少触碰，它不会经常给我带来麻烦，那么我就倾向于不去重构它
* 重构应该总是由经济利益驱动

### 代码所有权
-- 很多重构手法不仅会影响一个模块内部，还会影响该模块与系统其他部分的关系  
* 团队代码所有制，这样一支团队里的成员都可以修改这个团队拥有的代码，即便最初写代码的是别人。程序员可能各自分工负责系统的不同区域，但这种责任应该体现为监控自己责任区内发生的修改，而不是简单粗暴地禁止别人修改。

### 分支
-- 在隔离的分支上工作得越久，将完成的工作集成（integrate）回主线就会越困难
* 持续集成（CI） 副作用：你必须使用相关的实践以确保主线随时处于健康状态，必须学会将大功能拆分成小块，还必须使用特性开关（FG）将尚未完成又无法拆小的功能隐藏掉。

### 测试
-- “自测试的代码”这个要求太高，根本无法实现。
* 团队必须投入时间与精力在测试上，但收益是绝对划算的。自测试的代码不仅使重构成为可能，而且使添加新功能更加安全

### 遗留代码
-- 遗留代码往往很复杂，测试又不足，而且最关键的是，是别人写的
* 你先找到程序的接缝，在接缝处插入测试，如此将系统置于测试覆盖之下。
* 每次触碰一块代码时，我会尝试把它变好一点点——至少要让代码比我到达时更干净。

### 数据库
* 借助数据迁移脚本，将数据库结构的修改与代码相结合，使大规模的、涉及数据库的修改可以比较容易地开展

