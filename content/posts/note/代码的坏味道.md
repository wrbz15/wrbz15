---
title: 代码的坏味道
date: 2022-08-27T19:17:58+08:00
lastmod: 2022-08-27T19:17:58+08:00
author: ["wrbz15"]
categories: 
- 敏捷开发
tags: 
- 敏捷开发
- 重构
description: ""
weight: # 输入1可以顶置文章，用来给文章展示排序，不填就默认按时间排序
slug: ""
draft: false # 是否为草稿
comments: true
showToc: true # 显示目录
TocOpen: true # 自动展开目录
hidemeta: false # 是否隐藏文章的元信息，如发布日期、作者等
disableShare: true # 底部不显示分享栏
showbreadcrumbs: true #顶部显示当前路径
cover:
    image: ""
    caption: ""
    alt: ""
    relative: false
---
**代码的坏味道会告诉你一些迹象，它会指出“这里有一个可以用重构解决的问题”。**
## 神秘命名（Mysterious Name）
表现：难以理解实际的功能和用法

解决手段：
* 改名可能是最常用的重构手法，包括改变函数声明（124）（用于给函数改名）、变量改名（137）、字段改名（244）等
* 如果你想不出一个好名字，说明背后很可能潜藏着更深的设计问题。为一个恼人的名字所付出的纠结，常常能推动我们对代码进行精简
## 重复代码（Duplicated Code）
表现： 如果要修改重复代码，你必须找出所有的副本来修改

解决手段： 
* 如果同一个类的两个函数含有相同的表达式，采用提炼函数（106）提炼出重复的代码，然后让这两个地点都调用被提炼出来的那一段代码
* 如果重复代码只是相似而不是完全相同，请首先尝试用移动语句（223）重组代码顺序，把相似的部分放在一起以便提炼
* 如果重复的代码段位于同一个超类的不同子类中，可以使用函数上移（350）来避免在两个子类之间互相调用

## 过长函数（Long Function）
表现： 函数越长，就越难理解

解决办法：每当感觉需要以注释来说明点什么的时候，我们就把需要说明的东西写进一个独立函数中，并以其用途（而非实现手法）命名

解决手段：
* 提炼函数（106）。找到函数中适合集中在一起的部分，将它们提炼出来形成一个新函数
* 如果函数内有大量的参数和临时变量，它们会对你的函数提炼形成阻碍。如果你尝试运用提炼函数（106），最终就会把许多参数传递给被提炼出来的新函数，导致可读性几乎没有任何提升。此时，你可以经常运用以查询取代临时变量（178）来消除这些临时元素。引入参数对象（140）和保持对象完整（319）则可以将过长的参数列表变得更简洁一些，杀手锏——以命令取代函数（337）。
* 条件表达式和循环常常也是提炼的信号。你可以使用分解条件表达式（260）处理条件表达式。对于庞大的 switch 语句，其中的每个分支都应该通过提炼函数（106）变成独立的函数调用。如果有多个 switch 语句基于同一个条件进行分支选择，就应该使用以多态取代条件表达式（272）。
* 循环，你应该将循环和循环内的代码提炼到一个独立的函数中。如果你发现提炼出的循环很难命名，可能是因为其中做了几件不同的事。如果是这种情况，请勇敢地使用拆分循环（227）将其拆分成各自独立的任务。

## 过长参数列表（Long Parameter List）
表现：过长的参数列表本身也经常令人迷惑

解决手段：
* 如果可以向某个参数发起查询而获得另一个参数的值，那么就可以使用以查询取代参数（324）去掉这第二个参数
* 如果你发现自己正在从现有的数据结构中抽出很多数据项，就可以考虑使用保持对象完整（319）手法，直接传入原来的数据结构
* 如果有几项参数总是同时出现，可以用引入参数对象（140）将其合并成一个对象
* 如果某个参数被用作区分函数行为的标记（flag），可以使用移除标记参数（314）

## 全局数据（Global Data）
表现：从代码库的任何一个角落都可以修改它，而且没有任何机制可以探测出到底哪段代码做出了修改

解决手段：
* 封装变量（132）：把全局数据用一个函数包装起来，至少你就能看见修改它的地方，并开始控制对它的访问，随后搬移到一个类或模块中，只允许模块内的代码使用它，从而尽量控制其作用域

## 可变数据（Mutable Data）
表现：对数据的修改经常导致出乎意料的结果和难以发现的 bug

解决手段：
* 封装变量（132）来确保所有数据更新操作都通过很少几个函数来进行，使其更容易监控和演进
* 如果一个变量在不同时候被用于存储不同的东西，可以使用拆分变量（240）将其拆分为各自不同用途的变量，从而避免危险的更新操作。使用移动语句（223）和提炼函数（106）尽量把逻辑从处理更新操作的代码中搬移出来，将没有副作用的代码与执行数据更新操作的代码分开。
* 设计 API 时，可以使用将查询函数和修改函数分离（306）确保调用者不会调到有副作用的代码
* 尽早使用移除设值函数（331）
* 如果可变数据的值能在其他地方计算出来, 使用以查询取代派生变量（248）
* 可以用函数组合成类（144）或者函数组合成变换（149）来限制需要对变量进行修改的代码量
* 如果一个变量在其内部结构中包含了数据，通常最好不要直接修改其中的数据，而是用将引用对象改为值对象（252）令其直接替换整个数据结构

## 发散式变化（Divergent Change）
表现：某个模块经常因为不同的原因在不同的方向上发生变化，导致一次变更要修改多次

解决手段：
* 如果发生变化的两个方向自然地形成了先后次序，就可以用拆分阶段（154）将两者分开，两者之间通过一个清晰的数据结构进行沟通
* 如果两个方向之间有更多的来回调用，就应该先创建适当的模块，然后用搬移函数（198）把处理逻辑分开
* 如果函数内部混合了两类处理逻辑，应该先用提炼函数（106）将其分开，然后再做搬移
* 如果模块是以类的形式定义的，就可以用提炼类（182）来做拆分

##  霰弹式修改（Shotgun Surgery）
表现： 每遇到某种变化，你都必须在许多不同的类内做出许多小修改

解决手段：
* 使用搬移函数（198）和搬移字段（207）把所有需要修改的代码放进同一个模块里
* 如果有很多函数都在操作相似的数据，可以使用函数组合成类（144）
* 如果有些函数的功能是转化或者充实数据结构，可以使用函数组合成变换（149）
* 如果一些函数的输出可以组合后提供给一段专门使用这些计算结果的逻辑，这种时候常常用得上拆分阶段（154）

## 依恋情结（Feature Envy）
表现： 一个函数跟另一个模块中的函数或者数据交流格外频繁，远胜于在自己所处模块内部的交流

解决手段：
* 将总是一起变化的东西放在一块儿。数据和引用这些数据的行为总是一起变化的，但也有例外。如果例外出现，我们就搬移那些行为，保持变化只在一地发生。

## 数据泥团（Data Clumps）
表现：相同的三四项数据：两个类中相同的字段、许多函数签名中相同的参数

评判方式：删掉众多数据中的一项。如果这么做，其他数据有没有因而失去意义？如果它们不再有意义，这就是一个明确信号：你应该为它们产生一个新对象

解决手段：
* 运用提炼类（182）将它们提炼到一个独立对象中。然后将注意力转移到函数签名上，运用引入参数对象（140）或保持对象完整（319）为它瘦身

## 基本类型偏执（Primitive Obsession）
表现：不愿意创建对自己的问题域有用的基本类型

解决手段：
* 以对象取代基本类型（174）将原本单独存在的数据值替换为对象
* 如果想要替换的数据值是控制条件行为的类型码，则可以运用以子类取代类型码（362）加上以多态取代条件表达式（272）的组合将它换掉
* 如果你有一组总是同时出现的基本类型数据，这就是数据泥团的征兆，应该运用提炼类（182）和引入参数对象（140）来处理

## 重复的 switch （Repeated Switches）
表现：每当你想增加一个选择分支时，必须找到所有的 switch，并逐一更新

解决手段：
* 以多态取代条件表达式（272）消除掉

## 循环语句（Loops）
解决手段：可以使用以管道取代循环（231），管道操作（如 filter 和 map）可以帮助我们更快地看清被处理的元素以及处理它们的动作

## 冗赘的元素（Lazy Element）
表现：程序元素（如类和函数）能给代码增加结构，从而支持变化、促进复用或者哪怕只是提供更好的名字也好，但有时我们真的不需要这层额外的结构。

解决手段：
* 使用内联函数（115）或是内联类（186）
* 如果这个类处于一个继承体系中，可以使用折叠继承体系（380）

## 夸夸其谈通用性（Speculative Generality）
表现: 企图以各式各样的钩子和特殊情况来处理一些非必要的事情

解决手段：
* 如果你的某个抽象类其实没有太大作用，请运用折叠继承体系（380）
* 不必要的委托可运用内联函数（115）和内联类（186）除掉
* 如果函数的某些参数未被用上，可以用改变函数声明（124）去掉这些参数
* 如果有并非真正需要、只是为不知远在何处的将来而塞进去的参数，也应该用改变函数声明（124）去掉
* 如果函数或类的唯一用户是测试用例，可以先删掉测试用例，然后使用移除死代码（237）

## 临时字段（Temporary Field）
表现：其内部某个字段仅为某种特定情况而设

解决手段：
* 使用提炼类（182）给这个可怜的孤儿创造一个家，然后用搬移函数（198）把所有和这些字段相关的代码都放进这个新家。也许你还可以使用引入特例（289）在“变量不合法”的情况下创建一个替代对象，从而避免写出条件式代码。

## 过长的消息链（Message Chains）
表现：一长串取值函数或一长串临时变量。

解决手段：
* 应该使用隐藏委托关系（189）。你可以在消息链的不同位置采用这种重构手法。
* 以提炼函数（106）把使用该对象的代码提炼到一个独立的函数中，再运用搬移函数（198）把这个函数推入消息链。
* 如果还有许多客户端代码需要访问链上的其他对象，同样添加一个函数来完成此事。

## 中间人（Middle Man）
表现：过度运用委托

解决手段：
* 可以运用内联函数（115）把它们放进调用端
* 如果这些中间人还有其他行为，可以运用以委托取代超类（399）或者以委托取代子类（381）把它变成真正的对象

## 内幕交易（Insider Trading）
表现：模块之间大量交换数据

解决手段：
* 用搬移函数（198）和搬移字段（207）减少
* 如果两个模块有共同的兴趣，可以尝试再新建一个模块，把这些共用的数据放在一个管理良好的地方；或者用隐藏委托关系（189），把另一个模块变成两者的中介
* 继承常会造成密谋，以委托取代子类（381）或以委托取代超类（399）让它离开继承体系

## 过大的类（Large Class）
表现：利用单个类做太多事情，其内往往就会出现太多字段

解决手段：
* 运用提炼类（182）将几个变量一起提炼至新类内
* 提炼超类（375）或者以子类取代类型码（362）将类内的数个变量有着相同的前缀或后缀，提炼到某个组件/子类
* 看看使用者是否只用到了这个类所有功能的一个子集，每个这样的子集都可能拆分成一个独立的类。一旦识别出一个合适的功能子集，就试用提炼类（182）、提炼超类（375）或是以子类取代类型码（362）将其拆分出来

## 异曲同工的类（Alternative Classes with Different Interfaces）
表现：今天用这个类，未来可以换成用另一个类

解决手段：
* 但只有当两个类的接口一致时，才能做这种替换。可以用改变函数声明（124）将函数签名变得一致
* 运用搬移函数（198）将某些行为移入类中，直到两者的协议一致为止。如果搬移过程造成了重复代码，或许可运用提炼超类（375）补偿一下

## 纯数据类（Data Class）

表现： 纯数据类是指：它们拥有一些字段，以及用于访问（读写）这些字段的函数，除此之外一无长物

解决手段：
* 用封装记录（162）将它们封装起来。对于那些不该被其他类修改的字段，请运用移除设值函数（331）
* 搬移函数（198）把那些调用行为搬移到纯数据类里来。如果无法搬移整个函数，就运用提炼函数（106）产生一个可被搬移的函数
  
## 被拒绝的遗赠（Refused Bequest）
表现： 子类应该继承超类的函数和数据。但如果它们不想或不需要继承

解决手段：
* 这个子类新建一个兄弟类，再运用函数下移（359）和字段下移（361）把所有用不到的函数下推给那个兄弟
* 不愿意支持超类的接口，就不要虚情假意地糊弄继承体系，应该运用以委托取代子类（381）或者以委托取代超类（399）彻底划清界限

## 注释（Comments）
表现：你看到一段代码有着长长的注释，然后发现，这些注释之所以存在乃是因为代码很糟糕

解决手段：
* 试试提炼函数（106）；如果函数已经提炼出来，但还是需要注释来解释其行为，试试用改变函数声明（124）为它改名
* 如果你需要注释说明某些系统的需求规格，试试引入断言（302）